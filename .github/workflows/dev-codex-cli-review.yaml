name: dev-codex-cli-review

on:
  pull_request:
    branches: [dev]
    types: [opened, reopened, synchronize]
  pull_request_target:
    branches: [dev]
    types: [opened, reopened, synchronize]
  push:
    branches:
      - e2e-codex-review-*
  workflow_dispatch:
    inputs:
      pr_number:
        description: Pull request number to review
        required: true
        type: string

jobs:
  codex-cli:
    runs-on: ubuntu-latest
    environment: dev
    permissions:
      id-token: write
      contents: read
      pull-requests: write
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID || vars.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY || vars.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN || vars.AWS_SESSION_TOKEN }}
      CODEX_AMI_ID: ${{ secrets.CODEX_AMI_ID || vars.CODEX_AMI_ID }}
      CODEX_EXISTING_INSTANCE_ID: ${{ secrets.CODEX_EXISTING_INSTANCE_ID || vars.CODEX_EXISTING_INSTANCE_ID }}
      CODEX_EC2_SUBNET_ID: ${{ secrets.CODEX_EC2_SUBNET_ID || vars.CODEX_EC2_SUBNET_ID }}
      CODEX_EC2_SECURITY_GROUP_IDS: ${{ secrets.CODEX_EC2_SECURITY_GROUP_IDS || vars.CODEX_EC2_SECURITY_GROUP_IDS }}
      CODEX_EC2_KEY_NAME: ${{ secrets.CODEX_EC2_KEY_NAME || vars.CODEX_EC2_KEY_NAME }}
      CODEX_INSTANCE_TYPE: ${{ secrets.CODEX_INSTANCE_TYPE || vars.CODEX_INSTANCE_TYPE }}

    steps:
      - uses: actions/checkout@v4

      - name: create-context-files
        env:
          GITHUB_CONTEXT: ${{ tojson(github) }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CODEX_AUTH_JSON: ${{ secrets.CODEX_AUTH_JSON || vars.CODEX_AUTH_JSON }}
          CODEX_ID_RSA: ${{ secrets.CODEX_ID_RSA || vars.CODEX_ID_RSA }}
          PR_NUMBER: ${{ github.event.inputs.pr_number }}
          SESSION_NAME: ${{ github.event.repository.name }}-${{ github.run_id }}
          SPOT_INSTANCE_NAME: dev-aps1-ec2-codex-cli-${{ github.event.repository.name }}-${{ github.run_id }}
        run: |
          mkdir -p .github/tmp
          printf '%s' "$GITHUB_CONTEXT" > .github/tmp/github_context.json
          printf '%s' "$GITHUB_TOKEN" > .github/tmp/github_token.txt
          printf '%s' "$CODEX_AUTH_JSON" > .github/tmp/auth.json
          printf '%s' "$CODEX_ID_RSA" > .github/tmp/id_rsa
          chmod 600 .github/tmp/id_rsa

          python3 - <<'PY'
          import json
          import os
          import sys
          import urllib.request

          path = ".github/tmp/github_context.json"
          with open(path, "r", encoding="utf-8") as handle:
              ctx = json.load(handle)

          event = ctx.get("event") or {}
          pr = event.get("pull_request")
          if pr:
              sys.exit(0)

          token_path = ".github/tmp/github_token.txt"
          with open(token_path, "r", encoding="utf-8") as handle:
              token = handle.read().strip()

          repo = ctx.get("repository")
          if not repo:
              owner = ctx.get("repository_owner") or event.get("repository", {}).get("owner", {}).get("login", "")
              name = event.get("repository", {}).get("name", "")
              repo = f"{owner}/{name}" if owner and name else ""

          if not repo:
              raise SystemExit("Unable to determine repository from context.")

          api_url = ctx.get("api_url") or "https://api.github.com"
          pr_number = os.environ.get("PR_NUMBER", "").strip()
          pr_data = None

          def request_json(url):
              req = urllib.request.Request(
                  url,
                  headers={
                      "Authorization": f"Bearer {token}",
                      "Accept": "application/vnd.github+json",
                      "User-Agent": "codex-cli-review-bot",
                  },
              )
              with urllib.request.urlopen(req) as resp:
                  return json.loads(resp.read().decode("utf-8"))

          if pr_number:
              pr_data = request_json(f"{api_url}/repos/{repo}/pulls/{pr_number}")
          else:
              ref_name = ctx.get("ref_name") or ctx.get("ref", "").split("/")[-1]
              if not ref_name:
                  raise SystemExit("Unable to determine ref name for PR lookup.")
              owner = repo.split("/", 1)[0]
              prs = request_json(
                  f"{api_url}/repos/{repo}/pulls?state=open&head={owner}:{ref_name}"
              )
              if prs:
                  pr_data = prs[0]

          if not pr_data:
              raise SystemExit("Unable to resolve pull request for workflow_dispatch run.")

          event["pull_request"] = pr_data
          ctx["event"] = event
          with open(path, "w", encoding="utf-8") as handle:
              json.dump(ctx, handle)
          PY

      - name: run-codex-review
        env:
          SESSION_NAME: ${{ github.event.repository.name }}-${{ github.run_id }}
          SPOT_INSTANCE_NAME: dev-aps1-ec2-codex-cli-${{ github.event.repository.name }}-${{ github.run_id }}
        run: |
          set -euo pipefail

          if [[ -f .env ]]; then
            set -a
            source .env
            set +a
          fi

          log() {
            printf '%s\n' "[codex-review] $*"
          }

          require_file() {
            local path="$1"
            if [[ ! -f "$path" ]]; then
              log "Missing required file: $path"
              exit 1
            fi
          }

          require_cmd() {
            local cmd="$1"
            if ! command -v "$cmd" >/dev/null 2>&1; then
              log "Missing required command: $cmd"
              exit 1
            fi
          }

          REPO_ROOT="$PWD"
          TMP_DIR="$REPO_ROOT/.github/tmp"
          GITHUB_CONTEXT="$TMP_DIR/github_context.json"
          GITHUB_TOKEN_FILE="$TMP_DIR/github_token.txt"
          AUTH_FILE="$TMP_DIR/auth.json"
          SSH_KEY_FILE="$TMP_DIR/id_rsa"
          REVIEW_OUT="$TMP_DIR/codex_review.txt"
          PROMPT_FILE="$TMP_DIR/codex_prompt.txt"
          PAYLOAD_FILE="$TMP_DIR/review_payload.json"
          VALIDATION_ERROR_FILE="$TMP_DIR/validation_error.txt"

          write_prompt_file() {
            local feedback="${1:-}"
            cat > "$PROMPT_FILE" <<'PROMPT'
          You are running a PR code review. Read .github/tmp/github_context.json for PR metadata.
          Follow the instructions in AGENTS.md. Review only the PR diff against the base branch.
          You must output only a valid JSON object wrapped between lines BEGIN_REVIEW_JSON and END_REVIEW_JSON.
          JSON schema:
          {
            "event": "COMMENT" | "REQUEST_CHANGES" | "APPROVE",
            "body": "One-line verdict, then bullets grouped by severity (Blocking, Risk, Nit), then a testing note.",
            "comments": [
              {"path": "relative/path.ext", "line": 123, "body": "Inline comment text"}
            ]
          }
          Use paths relative to repo root. "line" is the line number in the new file (right side).
          Only include inline comments for lines that appear in the PR diff; omit uncertain ones.
          For every finding you mention in the body, include a corresponding inline comment that points to the relevant line.
          If you cannot anchor a finding to a changed line, omit that finding from the body.
          Do not include markdown headings or code fences. No text outside the JSON block. Output exactly one JSON block.
          PROMPT
            if [[ -n "$feedback" ]]; then
              printf '\nValidation feedback: %s\n' "$feedback" >> "$PROMPT_FILE"
              printf 'Fix the issues and output a single valid JSON block with proper commas and quotes.\n' >> "$PROMPT_FILE"
            fi
          }

          prepare_payload() {
            rm -f "$PAYLOAD_FILE" "$VALIDATION_ERROR_FILE"
            python3 - <<'PY'
          import json
          import re
          import subprocess
          from pathlib import Path

          context_path = ".github/tmp/github_context.json"
          token_path = ".github/tmp/github_token.txt"
          review_path = ".github/tmp/codex_review.txt"
          payload_path = ".github/tmp/review_payload.json"
          error_path = ".github/tmp/validation_error.txt"

          def fail(message):
              Path(error_path).write_text(str(message))
              raise SystemExit(message)

          def load_json(path):
              with open(path, "r", encoding="utf-8") as handle:
                  return json.load(handle)

          def read_text(path):
              with open(path, "r", encoding="utf-8") as handle:
                  return handle.read()

          def parse_repo_info(context):
              repo_full = context.get("repository")
              owner = ""
              repo = ""
              if isinstance(repo_full, str) and "/" in repo_full:
                  owner, repo = repo_full.split("/", 1)
              event = context.get("event") or {}
              if not owner:
                  owner = (
                      context.get("repository_owner")
                      or event.get("repository", {}).get("owner", {}).get("login", "")
                  )
              if not repo:
                  repo = event.get("repository", {}).get("name", "")
              if not owner or not repo:
                  raise ValueError("Unable to determine repository owner/name from context.")
              return owner, repo

          def parse_pr_info(context):
              event = context.get("event") or {}
              pr = event.get("pull_request") or {}
              pr_number = pr.get("number") or event.get("number")
              if not pr_number:
                  raise ValueError("Unable to determine pull request number from context.")
              base_sha = (pr.get("base") or {}).get("sha") or ""
              head_sha = (pr.get("head") or {}).get("sha") or context.get("sha") or ""
              head_repo = (pr.get("head") or {}).get("repo") or {}
              head_clone_url = head_repo.get("clone_url") or ""
              return int(pr_number), base_sha, head_sha, head_clone_url

          def ensure_commit(sha, fallback_url=None):
              if not sha:
                  return
              try:
                  subprocess.run(
                      ["git", "cat-file", "-e", sha],
                      check=True,
                      stdout=subprocess.DEVNULL,
                      stderr=subprocess.DEVNULL,
                  )
              except subprocess.CalledProcessError:
                  try:
                      subprocess.run(
                          ["git", "fetch", "--no-tags", "origin", sha],
                          check=True,
                          stdout=subprocess.DEVNULL,
                          stderr=subprocess.DEVNULL,
                      )
                  except subprocess.CalledProcessError:
                      if not fallback_url:
                          raise
                      subprocess.run(
                          ["git", "fetch", "--no-tags", fallback_url, sha],
                          check=True,
                          stdout=subprocess.DEVNULL,
                          stderr=subprocess.DEVNULL,
                      )

          def build_positions(diff_text):
              positions = {}
              current_path = None
              position = 0
              new_line = None
              diff_re = re.compile(r"^diff --git a/(.+) b/(.+)$")
              hunk_re = re.compile(r"^@@ -\\d+(?:,\\d+)? \\+(\\d+)(?:,\\d+)? @@")

              for raw in diff_text.splitlines():
                  diff_match = diff_re.match(raw)
                  if diff_match:
                      current_path = None
                      position = 0
                      new_line = None
                      b_path = diff_match.group(2)
                      if b_path == "/dev/null":
                          continue
                      current_path = b_path
                      positions.setdefault(current_path, {})
                      continue

                  if current_path is None:
                      continue

                  if raw.startswith("@@ "):
                      position += 1
                      hunk_match = hunk_re.match(raw)
                      new_line = int(hunk_match.group(1)) if hunk_match else None
                      continue

                  if raw.startswith("+++ ") or raw.startswith("--- "):
                      continue

                  if raw.startswith("\\"):
                      position += 1
                      continue

                  prefix = raw[:1]
                  if prefix in (" ", "+", "-"):
                      position += 1
                      if prefix in (" ", "+") and new_line is not None:
                          positions[current_path][new_line] = position
                          new_line += 1
                      continue

              return positions

          def extract_review_json(raw_text):
              start_token = "BEGIN_REVIEW_JSON"
              end_token = "END_REVIEW_JSON"
              start = raw_text.rfind(start_token)
              if start == -1:
                  raise ValueError("Missing BEGIN_REVIEW_JSON marker in codex output.")
              start += len(start_token)
              end = raw_text.find(end_token, start)
              if end == -1:
                  raise ValueError("Missing END_REVIEW_JSON marker in codex output.")
              json_text = raw_text[start:end].strip()
              if not json_text:
                  raise ValueError("Empty JSON block in codex output.")
              json_text = json_text.replace("***", "")
              first_brace = json_text.find("{")
              last_brace = json_text.rfind("}")
              if first_brace == -1 or last_brace == -1 or last_brace < first_brace:
                  raise ValueError("No JSON object found inside review block.")
              json_text = json_text[first_brace : last_brace + 1]
              return json.loads(json_text)

          try:
              context = load_json(context_path)
              token = read_text(token_path).strip()
              raw_review = read_text(review_path)
              review = extract_review_json(raw_review)
          except Exception as exc:
              fail(exc)

          owner, repo = parse_repo_info(context)
          pr_number, base_sha, head_sha, head_clone_url = parse_pr_info(context)

          if head_clone_url and head_clone_url.startswith("https://"):
              auth_head_clone_url = head_clone_url.replace(
                  "https://", f"https://x-access-token:{token}@"
              )
          else:
              auth_head_clone_url = ""

          ensure_commit(base_sha)
          ensure_commit(head_sha, fallback_url=auth_head_clone_url or None)

          if base_sha and head_sha:
              diff_args = ["git", "diff", "--no-color", "--unified=3", f"{base_sha}...{head_sha}"]
          else:
              diff_args = ["git", "diff", "--no-color", "--unified=3", "HEAD~1...HEAD"]

          diff_text = subprocess.check_output(diff_args, text=True)
          positions = build_positions(diff_text)
          file_positions_cache = {}

          def position_for(path, line):
              pos = positions.get(path, {}).get(line)
              if pos:
                  return pos
              if path in file_positions_cache:
                  return file_positions_cache[path].get(line)
              if base_sha and head_sha:
                  file_args = [
                      "git",
                      "diff",
                      "--no-color",
                      "--unified=10000",
                      f"{base_sha}...{head_sha}",
                      "--",
                      path,
                  ]
              else:
                  file_args = [
                      "git",
                      "diff",
                      "--no-color",
                      "--unified=10000",
                      "HEAD~1...HEAD",
                      "--",
                      path,
                  ]
              try:
                  file_diff = subprocess.check_output(file_args, text=True)
              except subprocess.CalledProcessError:
                  file_diff = ""
              file_positions_cache[path] = build_positions(file_diff).get(path, {})
              return file_positions_cache[path].get(line)

          event = str(review.get("event", "COMMENT")).upper()
          if event not in {"COMMENT", "REQUEST_CHANGES", "APPROVE"}:
              event = "COMMENT"

          body = str(review.get("body", "")).strip()
          if not body:
              fail("Review body is empty after parsing JSON.")

          raw_comments = review.get("comments") or []
          api_comments = []
          def candidate_paths(value):
              candidates = []
              if value:
                  candidates.append(value)
              if value.startswith("a/") or value.startswith("b/"):
                  candidates.append(value[2:])
              if value.startswith("github/"):
                  candidates.append("." + value)
              if value.startswith(".github/"):
                  candidates.append(value[1:])
              return [c for c in candidates if c]
          for entry in raw_comments:
              if not isinstance(entry, dict):
                  continue
              path = str(entry.get("path", "")).strip().strip("`\"")
              if path.startswith("./"):
                  path = path[2:]
              if path.startswith("/"):
                  path = path[1:]
              body_text = str(entry.get("body", "")).strip()
              try:
                  line = int(entry.get("line"))
              except (TypeError, ValueError):
                  continue
              if not path or not body_text:
                  continue
              matched = False
              for candidate in candidate_paths(path):
                  position = position_for(candidate, line)
                  if not position:
                      continue
                  api_comments.append({"path": candidate, "position": position, "body": body_text})
                  matched = True
                  break
              if not matched:
                  continue

          findings = [
              line.strip()
              for line in body.splitlines()
              if line.strip().startswith("-") and "none" not in line.lower()
          ]
          if findings and not raw_comments:
              fail("Findings present but no inline comments were provided.")
          if raw_comments and not api_comments:
              fail("Inline comments could not be mapped to diff positions.")

          payload = {"body": body, "event": event}
          if head_sha:
              payload["commit_id"] = head_sha
          if api_comments:
              payload["comments"] = api_comments

          Path(payload_path).write_text(json.dumps(payload))
          PY
          }

          : "${SESSION_NAME:?Missing SESSION_NAME}"

          EXISTING_INSTANCE_ID="${CODEX_EXISTING_INSTANCE_ID:-}"
          if [[ -z "$EXISTING_INSTANCE_ID" ]]; then
            : "${SPOT_INSTANCE_NAME:?Missing SPOT_INSTANCE_NAME}"
            : "${CODEX_AMI_ID:?Missing CODEX_AMI_ID}"
            : "${CODEX_EC2_SUBNET_ID:?Missing CODEX_EC2_SUBNET_ID}"
            : "${CODEX_EC2_SECURITY_GROUP_IDS:?Missing CODEX_EC2_SECURITY_GROUP_IDS}"
            : "${CODEX_EC2_KEY_NAME:?Missing CODEX_EC2_KEY_NAME}"
            : "${CODEX_INSTANCE_TYPE:?Missing CODEX_INSTANCE_TYPE}"
          fi

          require_file "$GITHUB_CONTEXT"
          require_file "$GITHUB_TOKEN_FILE"
          require_file "$AUTH_FILE"
          require_file "$SSH_KEY_FILE"

          chmod 600 "$SSH_KEY_FILE"

          require_cmd aws
          require_cmd ssh
          require_cmd scp
          require_cmd python3

          AWS_REGION="ap-south-1"
          export AWS_REGION
          export AWS_DEFAULT_REGION="$AWS_REGION"

          SUBNET_ID="$CODEX_EC2_SUBNET_ID"
          SECURITY_GROUP_IDS="$CODEX_EC2_SECURITY_GROUP_IDS"
          KEY_NAME="$CODEX_EC2_KEY_NAME"
          INSTANCE_TYPE="$CODEX_INSTANCE_TYPE"

          SECURITY_GROUP_IDS="$(echo "$SECURITY_GROUP_IDS" | tr ',' ' ' | xargs)"
          SECURITY_GROUP_IDS_COMMA="$(echo "$SECURITY_GROUP_IDS" | tr ' ' ',')"

          INSTANCE_ID=""
          SHOULD_TERMINATE="false"
          cleanup() {
            if [[ "$SHOULD_TERMINATE" == "true" && -n "$INSTANCE_ID" ]]; then
              log "Terminating instance: $INSTANCE_ID"
              aws ec2 terminate-instances --instance-ids "$INSTANCE_ID" >/dev/null
            fi
          }
          trap cleanup EXIT

          PUBLIC_IP=""
          if [[ -n "$EXISTING_INSTANCE_ID" ]]; then
            log "Using existing instance: $EXISTING_INSTANCE_ID"
            INSTANCE_ID="$EXISTING_INSTANCE_ID"
            aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"
          else
            if [[ -z "$SUBNET_ID" || -z "$SECURITY_GROUP_IDS" ]]; then
              log "Missing network config. Set CODEX_EC2_SUBNET_ID and CODEX_EC2_SECURITY_GROUP_IDS."
              exit 1
            fi

            if [[ -z "$KEY_NAME" || "$KEY_NAME" == "None" ]]; then
              log "Missing EC2 key name. Set CODEX_EC2_KEY_NAME to match the ssh key."
              exit 1
            fi

            if [[ -z "$INSTANCE_TYPE" || "$INSTANCE_TYPE" == "None" ]]; then
              log "Missing instance type. Set CODEX_INSTANCE_TYPE."
              exit 1
            fi

            log "Launching spot instance in $AWS_REGION with AMI $CODEX_AMI_ID"
            RUN_ARGS=(
              --image-id "$CODEX_AMI_ID"
              --instance-type "$INSTANCE_TYPE"
              --instance-market-options "MarketType=spot"
              --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=$SPOT_INSTANCE_NAME},{Key=Session,Value=$SESSION_NAME}]"
              --network-interfaces "DeviceIndex=0,AssociatePublicIpAddress=true,SubnetId=$SUBNET_ID,Groups=$SECURITY_GROUP_IDS_COMMA"
            )
            if [[ -n "$KEY_NAME" && "$KEY_NAME" != "None" ]]; then
              RUN_ARGS+=(--key-name "$KEY_NAME")
            fi

            INSTANCE_ID="$(aws ec2 run-instances "${RUN_ARGS[@]}" \
              --query 'Instances[0].InstanceId' --output text)"

            log "Spot instance requested: $INSTANCE_ID"
            aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"
            SHOULD_TERMINATE="true"
          fi

          for _ in {1..30}; do
            PUBLIC_IP="$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" \
              --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)"
            if [[ -n "$PUBLIC_IP" && "$PUBLIC_IP" != "None" ]]; then
              break
            fi
            sleep 5
          done

          if [[ -z "$PUBLIC_IP" || "$PUBLIC_IP" == "None" ]]; then
            log "Failed to obtain public IP for $INSTANCE_ID"
            exit 1
          fi

          SSH_USER="ubuntu"
          REMOTE_WORKDIR="/home/$SSH_USER/codex-work/$SESSION_NAME"
          PROMPT_REMOTE="$REMOTE_WORKDIR/.github/tmp/codex_prompt.txt"

          SSH_OPTS=(-i "$SSH_KEY_FILE" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=15 -o LogLevel=ERROR)

          log "Waiting for ssh on $PUBLIC_IP"
          for _ in {1..30}; do
            if ssh "${SSH_OPTS[@]}" "$SSH_USER@$PUBLIC_IP" "echo ready" >/dev/null 2>&1; then
              break
            fi
            sleep 5
          done

          log "Creating remote directories"
          ssh "${SSH_OPTS[@]}" "$SSH_USER@$PUBLIC_IP" \
            "mkdir -p ~/.codex '$REMOTE_WORKDIR/.github/tmp'"

          log "Uploading auth.json"
          scp "${SSH_OPTS[@]}" "$AUTH_FILE" "$SSH_USER@$PUBLIC_IP:~/.codex/auth.json" >/dev/null

          log "Uploading github_context.json"
          scp "${SSH_OPTS[@]}" "$GITHUB_CONTEXT" \
            "$SSH_USER@$PUBLIC_IP:$REMOTE_WORKDIR/.github/tmp/github_context.json" >/dev/null

          log "Uploading github_token.txt"
          scp "${SSH_OPTS[@]}" "$GITHUB_TOKEN_FILE" \
            "$SSH_USER@$PUBLIC_IP:$REMOTE_WORKDIR/.github/tmp/github_token.txt" >/dev/null

          log "Cloning PR repo on remote"
          ssh "${SSH_OPTS[@]}" "$SSH_USER@$PUBLIC_IP" \
            "REMOTE_WORKDIR='$REMOTE_WORKDIR' bash -s" <<'REMOTE_CLONE'
          set -euo pipefail
          cd "$REMOTE_WORKDIR"

          python3 - <<'PY' > .github/tmp/pr_meta.sh
          import json
          from pathlib import Path

          ctx = json.loads(Path(".github/tmp/github_context.json").read_text())
          event = ctx.get("event") or {}
          pr = event.get("pull_request") or {}

          owner_repo = ctx.get("repository") or ""
          if not owner_repo:
              owner = ctx.get("repository_owner") or event.get("repository", {}).get("owner", {}).get("login", "")
              name = event.get("repository", {}).get("name", "")
              owner_repo = f"{owner}/{name}" if owner and name else ""

          pr_number = pr.get("number") or event.get("number")
          base_ref = (pr.get("base") or {}).get("ref") or "dev"
          head_sha = (pr.get("head") or {}).get("sha") or ""

          def esc(value):
              return str(value).replace("\\", "\\\\").replace('"', '\\"')

          print(f'OWNER_REPO="{esc(owner_repo)}"')
          print(f'PR_NUMBER="{esc(pr_number or "")}"')
          print(f'BASE_REF="{esc(base_ref)}"')
          print(f'HEAD_SHA="{esc(head_sha)}"')
          PY

          # shellcheck disable=SC1091
          source .github/tmp/pr_meta.sh

          if [[ -z "$OWNER_REPO" ]]; then
            echo "Missing repository info in github_context.json" >&2
            exit 1
          fi

          TOKEN="$(cat .github/tmp/github_token.txt)"
          CLONE_URL="https://x-access-token:${TOKEN}@github.com/${OWNER_REPO}.git"

          if [[ ! -d repo/.git ]]; then
            git clone "$CLONE_URL" repo
          fi

          cd repo
          git remote set-url origin "$CLONE_URL"
          git fetch origin "$BASE_REF"

          if [[ -n "$PR_NUMBER" ]]; then
            git fetch origin "pull/${PR_NUMBER}/head:pr-head"
            git checkout pr-head
          elif [[ -n "$HEAD_SHA" ]]; then
            git checkout "$HEAD_SHA"
          fi

          git remote set-url origin "https://github.com/${OWNER_REPO}.git"
          REMOTE_CLONE

          log "Writing AGENTS.md on remote"
          ssh "${SSH_OPTS[@]}" "$SSH_USER@$PUBLIC_IP" \
            "REMOTE_WORKDIR='$REMOTE_WORKDIR' bash -s" <<'REMOTE_SETUP'
          set -euo pipefail
          cat > "$REMOTE_WORKDIR/AGENTS.md" <<'AGENTS'
          ## Codex Review Agent

          You are running a pull-request code review. Focus on correctness, security, and missing tests.

          ### Context
          - PR metadata is in `.github/tmp/github_context.json`.
          - If no git repo exists, clone it using the repo info in the context file.
          - A GitHub token for cloning private repos is in `.github/tmp/github_token.txt`.

          ### Expectations
          - Review only the changes in this PR. If git history is available, use `git diff` against the base ref.
          - Call out bugs, risky behavior changes, and missing tests first.
          - Keep the review concise and actionable.

          ### Output Format
          - Start with a one-line overall verdict.
          - Then list findings as short bullets grouped by severity: `Blocking`, `Risk`, `Nit`.
          - End with a brief testing note (what was or was not validated).
          - Do not include code fences or markdown headings.

          ### Structured Output
          - Output only a JSON object between lines `BEGIN_REVIEW_JSON` and `END_REVIEW_JSON`.
          - JSON schema:
            {
              "event": "COMMENT" | "REQUEST_CHANGES" | "APPROVE",
              "body": "Verdict line + grouped bullets + testing note",
              "comments": [
                {"path": "relative/path.ext", "line": 123, "body": "Inline comment text"}
              ]
            }
          - For every finding in the body, include a matching inline comment pointing to the relevant changed line.
          - If you cannot anchor a finding to a changed line, omit that finding from the body.
          AGENTS
          REMOTE_SETUP

          log "Running Codex review"
          VALIDATION_ERROR=""
          ATTEMPT=1
          MAX_ATTEMPTS=2
          while [[ $ATTEMPT -le $MAX_ATTEMPTS ]]; do
            write_prompt_file "$VALIDATION_ERROR"
            scp "${SSH_OPTS[@]}" "$PROMPT_FILE" "$SSH_USER@$PUBLIC_IP:$PROMPT_REMOTE" >/dev/null
            log "Codex attempt $ATTEMPT"
            set +e
            ssh "${SSH_OPTS[@]}" "$SSH_USER@$PUBLIC_IP" \
              "REMOTE_WORKDIR='$REMOTE_WORKDIR' bash -s" <<'REMOTE_EOF' |& tee "$REVIEW_OUT"
          set -euo pipefail
          source "$REMOTE_WORKDIR/.github/tmp/pr_meta.sh"
          cd "$REMOTE_WORKDIR/repo"

          export PATH="/usr/local/bin:/usr/bin:/bin:$PATH"
          CODEX_BIN="$(command -v codex || true)"
          if [[ -z "$CODEX_BIN" && -x /usr/local/bin/codex ]]; then
            CODEX_BIN="/usr/local/bin/codex"
          fi
          if [[ -z "$CODEX_BIN" ]]; then
            echo "codex not found in PATH" >&2
            exit 1
          fi

          timeout 10m "$CODEX_BIN" exec -m gpt-5.2-codex \
            --config model_reasoning_effort=high \
            --dangerously-bypass-approvals-and-sandbox \
            --skip-git-repo-check \
            < "$REMOTE_WORKDIR/.github/tmp/codex_prompt.txt"
          REMOTE_EOF
            SSH_STATUS=${PIPESTATUS[0]}
            set -euo pipefail
            if [[ $SSH_STATUS -ne 0 ]]; then
              log "Codex review failed with status $SSH_STATUS"
              : > "$REVIEW_OUT"
            fi

            if [[ ! -s "$REVIEW_OUT" ]]; then
              VALIDATION_ERROR="Codex produced no output."
              ATTEMPT=$((ATTEMPT + 1))
              continue
            fi

            if prepare_payload; then
              break
            fi

            if [[ -f "$VALIDATION_ERROR_FILE" ]]; then
              VALIDATION_ERROR="$(cat "$VALIDATION_ERROR_FILE")"
            else
              VALIDATION_ERROR="Review output failed validation."
            fi
            : > "$REVIEW_OUT"
            ATTEMPT=$((ATTEMPT + 1))
          done

          if [[ ! -s "$PAYLOAD_FILE" ]]; then
            log "Codex output failed validation; not posting a review."
            exit 1
          fi

          log "Posting review to GitHub"
          python3 - <<'PY'
          import json
          import urllib.error
          import urllib.request

          context_path = ".github/tmp/github_context.json"
          token_path = ".github/tmp/github_token.txt"
          payload_path = ".github/tmp/review_payload.json"

          def load_json(path):
              with open(path, "r", encoding="utf-8") as handle:
                  return json.load(handle)

          def read_text(path):
              with open(path, "r", encoding="utf-8") as handle:
                  return handle.read()

          def parse_repo_info(context):
              repo_full = context.get("repository")
              owner = ""
              repo = ""
              if isinstance(repo_full, str) and "/" in repo_full:
                  owner, repo = repo_full.split("/", 1)
              event = context.get("event") or {}
              if not owner:
                  owner = (
                      context.get("repository_owner")
                      or event.get("repository", {}).get("owner", {}).get("login", "")
                  )
              if not repo:
                  repo = event.get("repository", {}).get("name", "")
              if not owner or not repo:
                  raise ValueError("Unable to determine repository owner/name from context.")
              return owner, repo

          def parse_pr_number(context):
              event = context.get("event") or {}
              pr = event.get("pull_request") or {}
              pr_number = pr.get("number") or event.get("number")
              if not pr_number:
                  raise ValueError("Unable to determine pull request number from context.")
              return int(pr_number)

          context = load_json(context_path)
          token = read_text(token_path).strip()
          payload = load_json(payload_path)

          owner, repo = parse_repo_info(context)
          pr_number = parse_pr_number(context)
          api_url = context.get("api_url") or "https://api.github.com"
          url = f"{api_url}/repos/{owner}/{repo}/pulls/{pr_number}/reviews"

          data = json.dumps(payload).encode("utf-8")
          headers = {
              "Authorization": f"Bearer {token}",
              "Accept": "application/vnd.github+json",
              "Content-Type": "application/json",
              "User-Agent": "codex-cli-review-bot",
              "X-GitHub-Api-Version": "2022-11-28",
          }

          request = urllib.request.Request(url, data=data, headers=headers, method="POST")
          try:
              with urllib.request.urlopen(request) as response:
                  if response.status not in (200, 201):
                      raise SystemExit(
                          f"GitHub API returned status {response.status}: {response.read()}"
                      )
          except urllib.error.HTTPError as exc:
              message = exc.read().decode("utf-8", errors="replace")
              raise SystemExit(f"GitHub API error: {exc.code} {message}") from exc

          print(
              f"Posted review to {owner}/{repo} PR #{pr_number} with {len(api_comments)} comments"
          )
          PY

          log "Review posted successfully"
